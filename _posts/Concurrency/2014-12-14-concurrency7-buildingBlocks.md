---
layout: default
tags: concurrency
title: 并发编程学习笔记（7）-基础构建模块
---

#并发编程学习笔记（7）-基础构建模块#

摘录于[《Java并发编程实战》](http://book.douban.com/subject/10484692/)

## 同步容器类 ##

同步容器类包括`Vector`和`Hashtable`，这类同步的容器类是由`Collections.synchronizedXxx`等工厂方法创建的。这些类实现线程安全的方式是：将它们的状态封装起来，并对每个共有方法都进行同步，使得每次只有一个线程能访问容器的状态。

### 同步容器类的问题 ###

在某些情况下可能需要额外的客户端加锁来保护复合操作（迭代、跳转以及条件运算）。

由于同步容器类要遵守同步策略，即支持客户端加锁，因此可能会创建一些新的操作，只要我们知道应该使用哪一个锁，那么这些新操作就与容器的其他操作一样都是原子操作。如果在一些新的操作没有进行客户端加锁，那么在并发情况下可能会抛出异常，但并不意味着底层的对象就不是线程安全的。底层的状态仍然是有效的，而抛出的异常也与其规范保持一致。

在迭代期间持有底层的锁，会降低并发性。

### 迭代器与ConcurrentModificationException ###

当容器类发现自己在迭代过程中被修改时，就会抛出一个`ConcurrentModificationException`异常，称为“及时失败”。

这种“及时失败”的迭代器并不是一种完备的处理机制，而只是“善意地”捕获并发错误，因此只能作为并发问题的预警指示器。采用的实现方式是，将计数器的变化与容器关联起来。然而这种检查是没有同步的情况下进行的，这是一种设计上的权衡，从而降低并发修改操作的检测代码对程序性能带来的影响。

如果不希望在迭代期间对容器加锁，那么一种替代方法就是“克隆”容器（在克隆过程中仍然需要对容器加锁，存在性能开销问题），并在副本上进行迭代。

### 隐藏迭代器 ###

所有这些间接的迭代操作都可能抛出`ConcurrentModificationException`。

如果状态与保护它的同步代码之间相隔越远，那么开发人员就越容易忘记在访问状态时使用正确的同步。

## 并发容器 ##

在Java5.0中

* 增加了`ConcurrentHashMap`替代同步容器类`Map`
* 增加了`CopyOnWriteArrayList`替代同步的`List`
* 增加了`CopyOnWriteArraySet`替代同步的`Set`
* 在新的`ConcurrentMap`接口中增加了对一些常见复合操作（比如若没有就添加，若相等则移除，若相等则替换）的支持
......

Java6中

* 增加了`ConcurrentSkipListMap`替代同步的`SortedMap`
* 增加了`ConcurrentSkipListSet`替代同步的`SortedSet`
......

### ConcurrentHashMap ###

同步容器类在执行每个操作期间都持有一个锁。在一些操作中，例如`HashMap.get`或`List.contains`，可能会包含大量的工作。

`ConcurrentHashMap`使用了分段锁（Lock Striping）来提供更高的并发性和伸缩性。

`ConcurrentHashMap`与其他并发容器一起增强了同步容器类：它们提供的迭代器不会抛出`ConcurrentModificationException`，因此不需要在迭代过程中对容器加锁。`ConcurrentHashMap`返回的迭代器具有弱一致性（Weakly Consistent），而并非“及时失败”。

对于一些需要在整个Map上进行计算的方法，例如`size`和`isEmpty`，这些方法的语义被略微减弱了以反映容器的并发特性。

只有当应用程序需要加锁Map以进行独占访问时或者需要依赖于同步Map带来的一些其他作用，才应该放弃使用`ConcurrentHashMap`。

### CopyOnWriteArrayList ###

“写入时复制（Copy-On-Write）”容器的线程安全性在于，只要正确地发布一个事实不可变的对象，那么在访问该对象时就不再需要进一步的同步。在每次修改时，都会创建并重新发布一个新的容器副本，从而实现可变性。

仅当迭代操作远远多于修改操作时，才应该使用“写入时复制”。这个准则很好地描述了许多事件通知系统：在分发通知时需要迭代已注册监听器链表，并调用每一个监听器，在大多数情况下，注册和注销事件监听器的操作远少于接收事件通知的操作。

## 阻塞队列和生产者-消费者模式 ##

阻塞队列支持生产者-消费者这种设计模式。该模式将“找出需要完成的工作”与“执行工作”这两个过程分离开来，并把工作项放入一个“待完成”列表中以便在随后处理，而不是找出后立即处理。

一种最常见的生产者-消费者设计模式就是线程池与工作队列的组合，在`Executor`任务执行框架中就体现了这种模式。

阻塞队列同样提供了一个`offer`方法，如果数据项不能被添加到队列中，那么就将返回一个失败状态。这样你就能创建更多灵活的策略来处理负荷过载的情况，**例如减轻负载，将多余的工作项序列化并写入磁盘，减少生产者的数量，或者通过某种方式来抑制生产者线程。**

**在构建高可靠的应用程序时，有界队列是一种强大的资源管理工具**：它们能抑制并防止产生过多的工作项，使应用程序在负荷过载的情况下变的更加健壮。由于实际情况不可预测，因此应该尽早通过阻塞队列在设计中构建资源管理机制。

`LinkBlockingQueue`和`ArrayBlockingQueue`是FIFO队列，比同步List拥有更好的并发性能。

`PriorityBlockingQueue`是一个按优先级排序的队列。

`SynchronousQueue`实际上不是一个真正的队列，因为它不会为队列中元素维护存储空间，它维护一组线程。与其他队列的区别就好比将文件直接交给同事，还是将文件放到她的邮箱中并希望她能尽快拿到文件。仅当有足够多的消费者，并且总是有一个消费者准备好获取交付的工作时，才适合使用。

### 串行线程封闭 ###

在`java.util.concurent`中实现的各种阻塞队列都包含了**足够的内部同步机制**，从而安全地将对象从生产者线程发布到消费者线程。

对于可变对象，生产者-消费者这种设计与阻塞队列一起，促进了串行线程封闭，从而将对象所有权从生产者交付给消费者。新的所有者线程可以对该对象做任意修改，因为它具有独占的访问权。

对象池利用了串行线程封闭，将对象“借给”一个请求线程。只要对象池包含足够的内部同步来安全地发布池中的对象，并且只要客户代码本身不会发布池中的对象，或者在讲对象返回给对象池后就不再使用它，那么就可以安全地在线程之间传递所有权。

### 双端队列与工作密取(Work Stealing) ###

Java6中`Deque`扩展了`Queue`，`BlockingDeque`扩展了`BlockingQueue`。`Deque`是一个双端队列，实现了在队列头和队列尾的高校插入赫然移除。具体实现包括`ArrayDeque`和`LinkedBlockingDeque`。

在生产者-消费者设计中，所有消费者有一个共享的工作队列，而在工作密取设计中，每个消费者都有各自的双端队列。如果一个消费者完成了自己双端队列中的全部工作，那么它可以从其他消费者双端队列末尾秘密地获取工作。密取工作模式比传统的生产者-消费者模式具有更高的可伸缩性，这是因为工作者线程不会在单个共享的任务队列上发生竞争。在大多数时候，它们都只是访问自己的双端队列，从而极大地减少了竞争。当工作者线程需要访问另一个队列时，它会从队列的尾部而不是从头部获取工作，因此进一步降低了队列上的竞争程度。

工作密取非常适用于既是消费者也是生产者问题-当执行某个工作时可能会导致出现更多的工作。例如网页爬虫、搜索图算法、垃圾回收阶段对堆进行标记。
