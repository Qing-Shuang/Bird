---
layout: default
tags: concurrency
title: 并发编程学习笔记8-基础构建模块
---

#并发编程学习笔记8-基础构建模块#

摘录于[《Java并发编程实战》](http://book.douban.com/subject/10484692/)

## 阻塞方法与中断方法 ##

当某方法抛出`InterruptedException`时，表示该方法是一个阻塞方法，如果这个方法被中断，那么它将努力提前结束阻塞状态。

`Thread`提供了`interrupt`方法，用于中断线程或者查询线程是否已经被中断。每个线程都有一个布尔类型的属性，表示线程的中断状态，当中断线程时将设置这个状态。

中断是一种协作机制。一个线程不能强制其他线程停止正在执行的操作而去执行其他的操作。方法对中断请求的响应度越高，就越容易及时取消那些执行时间很长的操作。

对中断的响应有两种选择：

* 传递 `InterruptedException`
* 恢复中断。有时候不能抛出 `InterruptedException`，例如当代码是`Runnable`的一部分时。

## 同步工具类 ##

在容器类中，阻塞队列时一种独特的类：它们不仅能作为保存对象的容器，还能协调生产者和消费者等线程之间的控制流。

同步工具类可以是任何一个对象，只要它根据其自身的状态来协调线程的控制流。

所有的同步工具类都包含一些特定的结构化属性：它们封装了一些状态，这些状态将决定执行同步工具类的线程时继续执行还是等待，此外还提供了一些方法对状态进行操作，以及另一些方法用于高效地等待同步工具类进入到预期状态。

### 闭锁 ###

闭锁是一种同步工具类，可以延迟线程的进度直到**其到达终止状态**。闭锁可以用来确保某些活动直到其他活动都完成后才继续执行。

### FutureTask ###

`FutureTask`表示的计算是通过`Callable`来实现的，相当于一种可生成结果的`Runnable`，并且可以处于以下3种状态：等待运行，正在运行和运行完成。

`FutureTask`将计算结果从执行计算的线程传递到获取这个结果的线程，而`FutureTask`的规范确保了这种传递过程能实现结果的安全发布。

`FutureTask`在`Executor`框架中表示异步任务，此外还可以用来表示一些时间较长的计算，这些计算可以在使用计算结果之前启动。

### 信号量 ###

计数信号量（Counting Semaphore）用来控制同时访问某个特定资源的操作数量，或者同时执行某个指定操作的数量。计数信号量还可以用来实现某种线程池，或者对容器施加边界。

`Semaphore`中管理着一组虚拟的许可（permit），许可的初始数量可通过构造函数来指定。在执行操作时可以首先获得许可（只要还有剩余的许可），并在使用之后释放许可。如果没有许可，那么`acquire`将阻塞直到有许可（或者直到被中断或者操作超时）。

计算信号量的一种简化形式是二值信号量，即初始值为1的`Semaphore`。二值信号量可以用做互斥体（mutex），并具备不可重入的加锁语义：谁拥有这个唯一的许可，谁就拥有了互斥锁。在这种实现中不包含真正的许可对象，并且`Semaphore`也不会将许可与线程关联起来，因此在一个线程中获得的许可可以在另一个线程中释放。

`Semaphore`可以用于实现资源池，例如数据库连接池。在构造阻塞对象池时，一种更简单的方法是使用BlockingQueue来保存池的资源。

### 栅栏 ###

栅栏（Barrier）类似于闭锁，它能阻塞**一组线程**直到某个事件发生。**栅栏与闭锁的关键区别在于，所有线程必须同时到达栅栏位置，才能继续执行。闭锁用于等待事件，而栅栏用于等待其他线程。**

在把模拟过程并行化时，为每个元素分配一个独立的线程是不现实的，因为这将产生过多的线程，而在协调这些线程上导致的开销将降低计算性能。合理的做法是，将问题分解成一定数量的子问题，为每个子问题分配一个线程来进行求解，之后再将所有的结果合并起来。

`CyclicBarrier`可以使一定数量的参与方反复地在栅栏位置汇集。
`Exchanger`是另一种形式的栅栏，它是一种两方（Two-Party）栅栏，各方在栅栏位置上交换数据。

数据交换的时机取决于应用程序的响应需求。最简单的方案是，当缓冲区被填满时，由填充任务进行交换，当缓冲区为空时，由清空任务进行交换。这样会把需要交换的次数降至最低，但如果新数据的到达率不可预测，那么一些数据的处理过程就将延迟。另一个方法是，不仅当缓冲被填满时进行交换，并且当缓冲被填充到一定程序并保持一定时间后，也进行交换。

## 构建高效且可伸缩的结果缓存 ##

### 尝试一 ###
使用`HashMap`来保存之前计算的结果。对计算方法`compute`进行同步。

**存在问题**：这种方法能确保线程安全性，但会带来一个明显的可伸缩性问题：每次只有一个线程能够执行`compute`。如果有多个线程在排队等待还未计算出的结果，那么`compute`方法的计算时间可能比没有“记忆”操作的计算时间更长。

### 尝试二 ###
用`ConcurrentHashMap`代替`HashMap`，由于`ConcurrentHashMap`是线程安全的，因此在访问底层`Map`时就不需要进行同步，避免“尝试一”中的串行性。

**存在问题**：如果某个线程启动了一个开销很大的计算，而其他线程并不知道，那么很可能会重复这个计算。

### 尝试三 ###
使用`FutureTask`来表达“线程X正在计算f(27)”这种情况，这样当另一个线程查找f(27)时，它能够知道最高效的方法是等待线程X计算结束，然后再去查询缓存“f(27)的结果是多少”。与“尝试二”的区别在于首先检查某个相应的计算是否已经开始，“尝试二”首先判断某个计算是否已经完成。

**存在问题**：

* 非原子的“先检查再执行”操作。可使用`ConcurrentHashMap`中的原子方法`putIfAbsent`。
* 当缓存的是Future而不是值时，将导致缓存污染（Cache-Pollution）问题：如果某个计算被取消或者失败，那么计算这个结果时将指明计算过程被取消或者失败。在这两种情况下，需要从缓存中移除该Future。
* 缓存逾期问题。可以通过使用`FutureTask`的子类来解决，在子类中为每个结果指定一个逾期时间，并定期扫描。
* 缓存清理问题，移除清理问题，即移除旧的计算结果以便为新的计算结果腾出空间。




