---
layout: default
tags: concurrency
title: 并发编程学习笔记（1）-对象的共享（可见性）
---

#并发编程学习笔记（1）-对象的共享（可见性）#

摘录于[《Java并发编程实战》](http://book.douban.com/subject/10484692/)

同步代码块和同步方法可以确保以原子的方式执行操作，但一种常见的误解是，认为关键字synchronized只能用于实现原子性或者确定“临界区（Critical Section）”。同步还有另一个重要的方面：内存可见性（Memory Visibility）。

##可见性##

在缺少同步的情况下，Java内存模型允许编译器对操作顺序进行**重排序**，并将数字缓存在寄存器中。此外，它还允许CPU对操作顺序进行重排序，并数字缓存在处理器特定的缓存中。

在没有同步的情况下，编译器、处理器以及运行时等都可能对操作的执行顺序进行一些意想不到的调整。在缺乏足够同步的多线程程序中，要想对内存操作的执行顺序进行判断，几乎无法得出正确的结论。

###失效数据###

在没有同步的情况下，线程去读取变量时，可能会得到一个已经失效的值。更糟糕的是，失效值可能不会同时出现：一个线程可能获得某个变量的最新值，而获得另一个变量的失效值。

失效数据还可能导致一些令人困惑的故障，例如意料之外的异常、被破坏的数据结构、不精确的计算以及无限循环等。

###非原子的64位操作###

当线程在没有同步的情况下读取变量时，可能会得到一个失效值，但至少这个值是由之前某个线程设置的值，而不是一个随机值。这种安全性保证也被称为**最低安全性（out-of-thin-airsafety）**。

最低安全性适用于绝大多数变量，当时存在一个例外：非volatile类型的64位数值变量。Java内存模型要求，变量的读取操作和写入操作都必须是原子操作，但对于非volatile类型的long和double变量，JVM允许将64位的读操作或写操作分解为两个32位的操作。**在编写Java虚拟机规范时，许多主流处理器架构还不能有效地提供64位数值的原子操作。**

###加锁与可见性###

加锁的含义不仅仅局限于互斥行为，还包括内存可见性。为了确保所有线程都能看待共享变量的最新值，所有执行读操作或者写操作的线程都必须在**同一个锁**上同步。

###Volatile变量###

Java语言提供一种稍弱的同步机制，即volatile变量，用来确保将变量的更新操作通知到其他线程。当把变量声明为volatile类型后，编译器与运行时都会注意到这个变量是共享的，因此不会将该变量上的操作与其他内存操作一起重排序。volatile变量不会被缓存在寄存器或者对其他处理器不可见的地方，因此在读取volatile变量时总能返回最新写入的值。

在访问volatile变量时不会执行加锁操作，因此也就不会执行线程阻塞，因此volatile变量是一种比sychronized关键字更轻量级的同步机制。

仅当volatile变量能简化代码的实现以及对同步策略的验证时，才应该使用它们。如果在验证正确性时需要对可见性进行复杂的判断，那么就不要使用volatile变量。volatile变量变量的正确性使用方式包括：确保它们自身状态的可见性，确保它们所引用对象的状态的可见性，以及标识一些重要的程序生命周期事件的发生（例如：初始化或关闭）。

volatile变量通常用做某个操作完成、发生中断或者状态的标志。volatile的语义并不足以确保递增操作的原子性，除非你能确保只有一个线程对变量执行写操作。

**加锁机制即可以确保可见性又可以确保原子性，而volatile变量只能确保可见性。**

当且仅当满足以下所有条件时，才应该使用volatile变量：
* 对变量的写入操作不依赖变量的当前值，或者你能确保只有单个线程更新变量的值。
* 该变量不会与其他状态变量一起纳入不变性条件中。
* 在访问变量时不需要加锁。