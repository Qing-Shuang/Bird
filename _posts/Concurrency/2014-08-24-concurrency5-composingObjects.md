---
layout: default
tags: concurrency
title: 并发编程学习笔记5-对象的组合
---

#并发编程学习笔记5-对象的组合#

摘录于[《Java并发编程实战》](http://book.douban.com/subject/10484692/)

## 实例封闭（Instance Confinement） ##

将数据封装在对象内部，可以将数据的访问限制在对象的方法上，从而更容易确保线程在访问数据时总能持有正确的锁。

被封闭对象一定不能超出它们既定的作用域。

实例封闭是构建线程安全类的一个最简单方式，它还使得在锁策略的选择上拥有了更多的灵活性。可以使用对象的内置锁来保护它的状态，也可以使用其他形式的锁，只要自始至终都使用同一个锁。实例封闭还使得不同的状态变量可以由不同的锁来保护。

在 Java 中，有些类（比如 `Collections.synchronizedList` 及其类似方法）的唯一用途就是将非线程安全的类（比如 `ArrayList` 和 `HashMap` ）转换为线程安全的类。

### Java 监视器模式 ###

遵循 Java 监视器模式的对象会把对象的所有可变状态都封装起来，并由对象的内置锁来保护。Java 中的 `Vector` 和 `HashTable` 都使用了该模式。

使用私有的锁对象而不是对象的内置锁（或任何其他可通过公有方式访问的锁）的好处：

* 客户代码无法得到私有的锁对象，也就无法（正确或者不正确地）参与到它的同步策略中。
* 客户代码无法得到私有的锁对象，也就不会产生活跃性问题。
* 要想验证某个公有访问的锁在程序中是否被正确地使用，则需要检查整个程序，而不是单个的类。

在 Java 监视器模式中，客户代码如果需要得到封闭的对象，可以通过复制该对象来维护线程安全性。但如果对象包含的数据量非常大的情况下将极大地降低性能。同时返回的信息是保持不变的，如果需要最新信息，那么就需要重新地刷新快照。

## 线程安全性的委托 ##

当从头开始构建一个类，或者将多个非程序安全的类组合为一个类时，Java 监视器模式是非常有用的。但是，**如果类中的各个组件都已经是线程安全的，是否还需要再增加一个额外的线程安全层？**

视情况而定。

* 在一个无状态的类中增加一个线程安全的状态变量，得到的组合对象仍然是线程安全的。该变量的状态也是这个类的状态。
* 将类的线程安全性委托给多个状态变量，只要这些变量是彼此独立的，即组合而成的类并不会在其包含的多个状态变量上增加任何不变性条件。
* 大多数组合对象在它们的状态变量之间存在着某些不变性条件。在这种情况下，这个类必须提供自己的加锁机制以保证这些复合操作都是原子操作。同时还必须避免这些状态变量。从而防止客户代码破坏其不变性条件。

各个状态组成部分都是线程安全并不能确保该类的线程安全性，这种问题类似于 `volatile` 变量规则：仅当一个变量**不**参与到包含其他状态变量的不变性条件时，才可以声明为 `volatile` 类型。

### 发布底层的状态变量 ###

当把线程安全性委托给某个对象的底层状态变量时，**在什么条件下才可以发布这些变量从而使其他类能修改它们？**

取决于在类中对这些变量施加了哪些不变性条件。

如果一个状态变量是线程安全的，并且没有任何不变性条件来约束它的值，在变量的操作上也不存在任何不允许的状态转换，那么就可以安全地发布这个变量。






