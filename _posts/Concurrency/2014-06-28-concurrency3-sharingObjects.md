---
layout: default
tags: concurrency
title: 并发编程学习笔记（3）-对象的共享
---

#并发编程学习笔记（3）-对象的共享#

摘录于[《Java并发编程实战》](http://book.douban.com/subject/10484692/)

##不变性##

当满足以下条件时，对象才是不可变的：
* 对象创建以后其状态就不能修改。
* 对象的所有域都是 `final` 类型。
* 对象是正确创建的（在对象的创建期间，`this` 引用没有逸出）。

线程安全性是不可变对象的固有属性之一，它们的不变性条件是由构造函数创建的。

###Final 域###

在 Java 内存模型中，`final` 域还有特殊的语义。`fianl` 域能确保初始化过程的安全性，从而可以不受限制地访问不可变对象，并在共享这些对象时无须同步。

正如“除非需要更高的可见性，否则应将所有的域都声明为私有域”是一个良好的编程习惯，“除非需要某个域是可变的，否则应将其声明为 `final` 域”也是一个良好的编程习惯。（可以简化对对象状态的判断）

###使用 Volatile 类型来发布不可变对象###

每当需要对一组相关数据以原子方式执行某个操作时，就可以考虑创建一个不可变的类来包含这些数据。

对于在访问和更新多个相关变量时出现的竞争条件问题，可以通过将这些变量全部保存在一个不可变对象中来消除。如果是一个可变的对象，那么就必须使用锁来确保原子性。如果是一个不可变对象，要更新对象中的这些变量，那么就可以创建一个新的容器对象，当其他使用原有对象的线程仍然会看到对象处于一致的状态。

##安全发布##

在多个线程间共享对象，必须确保安全地进行共享。如果只是将对象引用保存在公有域中，那么还不足以安全地发布这个对象。由于存在可见性问题，其他线程看到的对象将处于不一致的状态。

Java内存模型为不可变对象的共享提供了一种特殊的初始化安全性保证。

###不正确的发布：正确的对象被破坏###

一个尚未被完全创建的对象并不拥有完整性。某个观察该对象的线程将看到对象处于不一致的状态，然后看到对象的状态突然发生变化，即使线程在对象发布后还没有修改过它。

###不可变对象与初始化安全性###

即使某个对象的引用对其他线程是可见的，也并不意味着对象状态对于使用该对象的线程来说一定是可见的。

**任何线程都可以在不需要额外同步的情况下安全地访问不可变对象，即使在发布这些对象时没有使用同步。**这种保证还延伸到被正确创建对象中所有 final 类型的域。如果 final 类型的域所指向的是可变对象，那么在访问这些域所指向的对象的状态时仍然需要同步。

###安全发布的常用模式###

要安全地发布一个对象，对象的引用以及对象的状态必须同时对其他线程可见。一个正确构造的对象可以通过以下方式来安全发布：

* 在静态初始化函数中初始化一个对象引用。
* 将对象的引用保存到 `volatile` 类型的域或者 `AtomicReferance` 对象中。
* 将对象的引用保存到某个正确构造对象的 `final` 类型域中。
* 将对象的引用保存到一个由锁保护的域中。

线程安全库中的容器类保证了将对象放入到某个容器中，可以安全地将它发布给任何从这些容器访问它的线程。（无论是直接访问还是通过迭代器访问）。

###事实不可变对象###

如果对象从技术上来看是可变的，但其状态在发布后不会再改变，那么把这种对象成为“事实不可见对象（Effectively Immutable Object）”。这些对象不需要满足上文提出的不可变性的严格定义。

**在没有额外同步的情况下，任何线程都可以安全地使用被安全发布的事实不可变对象。**

###可变对象###

要安全地共享可变对象，这些对象就必须被安全地发布，并且必须是线程安全的或者由某个锁保护起来。

### 对象的发布需求取决于它的可变性 ###

* 不可变对象可以通过任意机制来发布。
* 事实不可变对象必须通过安全方式来发布。
* 可变对象必须通过安全方式来发布，并且必须是线程安全的或者由某个锁保护起来。

##在并发程序中使用和共享对象时的一些实用策略##

* 线程封闭。线程封闭的对象只能由一个线程拥有，对象被封闭在该线程中，并且只能由这个线程修改。
* 只读共享。在没有额外同步的情况下，共享的只读对象可以由多个线程并发访问，但任何线程都不能修改它。共享的只读对象包括不可变对象和事实不可变对象。
* 线程安全共享。线程安全的对象在其内部实现同步，因此多个线程可以通过对象的公有接口来进行访问而不需要进一步的同步。
* 保护对象。被保护的对象只能通过持有特定的锁来访问，保护对象包括封装在其他线程安全对象中对象，以及已发布的并且由某个特定锁保护的对象。