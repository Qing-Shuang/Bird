---
layout: default
tags: concurrency
title: 并发编程学习笔记（9）-任务执行
description: 测试
---

#并发编程学习笔记（9）-任务执行#

摘录于[《Java并发编程实战》](http://book.douban.com/subject/10484692/)

## 在线程中执行任务 ##

当围绕“任务执行”来设计应用程序结构时，第一步就是要找出清晰的任务边界。在理想情况下，各个任务之间是相互独立的：任务并不依赖于其他任务的状态、结果或边界效应。

### 串行地执行任务 ###

在单个线程中串行地执行各项任务。存在问题：任务可能包含了一组不同的运算与I/O操作，导致资源利用率非常低，因为当单线程在等待I/O操作完成时，CPU将处于空闲状态。

在某些情况中，串行处理方式能带来简单性或安全性。大多数GUI框架都通过单一的线程来串行地处理任务。<!--more-->

### 显式地为任务创建线程 ###

在正常负载情况下，“为每个任务分配一个线程”的方法能提升串行执行的性能。只要请求的到达速率不超过服务器的请求处理能力，那么这种方法可以同时带来更快的响应性和更高的吞吐率。

### 无限制创建线程的不足 ###

* 线程生命周期的开销非常高，如果请求的到达率非常高且请求的处理过程是轻量级的，那么为每个请求创建一个新城成将消耗大量的计算资源。
* 资源消耗，大量空闲的线程会占用许多内存，给垃圾回收期带来压力，而且大量线程在竞争CPU资源时还将产生其他的性能开销。
* 稳定性，在可创建线程的数量上存在一个限制。

## Executor框架 ##

上文两种方式都存在一些严格的限制：串行执行的问题在于其糟糕的响应性和吞吐量，而“为每个任务分配一个线程”的问题在于资源管理的复杂性。

`Executor`提供了一种标准的方法将任务的提交过程与执行过程解耦开来，并用`Runnable`来表示任务。还提供了对生命周期的支持，以及统计信息收集、应用程序管理机制和性能监视等机制。

### 执行策略 ###
* 在什么（What）线程中执行任务？
* 任务按照任何（What）顺序执行（FIFO、LIFO、优先级）？
* 有多少个（How Many）任务能并发执行？
* 在队列中有多少个（How Many）任务在等待执行？
* 如果任务由于过载而需要拒绝一个任务，那么应该选择哪一个（Which）任务？另外，如何（How）通知应用程序有任务被拒绝？
* 在执行一个任务之前或之后，应该进行哪些（What）动作？

尽管服务器不会因为创建了过多的线程而失败，但在足够长的时间内，如果任务到达的速度总是超过任务执行的速度，那么服务器仍有可能（只是更不易）耗尽内存，因为等待执行的Runnable队列将不断增长。

### Executor的生命周期 ###

`Executor`扩展了`ExecutorService`接口，`ExecutorService`的生命周期有3种状态：运行、关闭和已终止。

### 延迟任务与周期任务 ###

`Timer`存在一些缺陷：
* `Timer`支持基于绝对时间而不是相对时间的调度机制，因此任务的执行对系统时钟变化很敏感。
* `Timer`在执行所有定时任务时只会创建一个线程。如果某个任务的执行时间过长，那么将破坏其他`TimerTask`的定时准确性。
* `Timer`线程并不捕获异常，因此当`TimerTask`抛出未检查的异常时将终止定时线程。这种情况下，`Timer`也不会恢复线程的执行，而是会错误地认为整个`Timer`都被取消了。因此，已经被调度但尚未执行的`TimeTask`将不会再执行，新的任务也不能被调度，这个问题称之为“线程泄露[Thread Leakage]”。

可以考虑使用`ScheduledThreadPoolExecutor`来代替`Timer`。
如果要构建自己的调度服务，可以使用`DelayQueue`，它实现了`BlockingQueue`，并为`ScheduledThreadPoolExecutor`提供调度功能。从`DelayQueue`中返回的对象将根据它们的延迟时间进行排序。
