---
layout: default
tags: C
title: C\C++ 杂记
---

# C\C++ 杂记（const、指针和引用的使用时机、this指针） #

<div></div>

## const ##

* `const int *p`和`int const *q`都被声明为`const int`类型的指针。
* `int * const r`被声明为`int`类型的`const`指针。
* 如果`const`位于`*`的左侧，则`const`就是用来修饰指针所指向的变量，即指针指向为常量；如果`const`位于`*`的右侧，`const`就是修饰指针本身，即指针本身就是常量。
* `const int * const r`被生命为一个指向`const int`类型的`const`指针。
* `const`可以用于修饰常量静态字符串，可以在编译期检查出对只读内存区域的赋值(比如`str[4]="x"`)

以上摘录于[C语言的那些小秘密之const修饰符](http://blog.csdn.net/bigloomy/article/details/6595197)

## 何时使用指针，何时使用引用 ##

在以下情况使用指针：
* 考虑到存在不指向任何对象的可能（在这种情况下，你能够设置指针为空）
* 需要能够在不同的时刻指向不同的对象（在这种情况下，你能改变指针的指向）

在以下情况使用引用：
* 如果总是指向一个对象并且一旦指向一个对象后就不会改变指向
* 当你重载某个操作符时。最普遍的例子是操作符`[]`。这个操作符典型的用法是返回一个目标对象，其能被赋值。

以上摘录于[浅谈C++引用与指针](http://news.e800.com.cn/articles/2011/0804/492738.shtml)

## this指针 ##

对于类成员函数而言，并不是一个对象对应一个单独的成员函数体，而是此类的所有对象共用这个成员函数体。当程序被编译之后，此成员函数地址即已确定。而成员函数把属于此类的各个对象的数据区别开，需要依靠`this`指针。函数体内所有对类数据成员的访问，都会被转化为`this->`数据成员的方式。

`this`作用于是在类内部，当在类的非静态成员函数中访问类的非静态成员的时候，编译器会自动将对象本身的地址作为一个隐含参数传递给函数。也就是说，即使你没有写上`this`指针，编译器在编译的时候也是加上`this`的，它作为非静态成员函数的隐含形参，对各成员的访问均通过`this`进行。

`this`指针跟一般的函数参数的区别，一般的函数参数是直接压入栈中，而`this`指针却被放到了`ecx`寄存器中。

以上摘录于[为什么通过空指针（NULL）可以正确调用一些类的成员函数？](http://blog.csdn.net/g5dsk/article/details/7017387)

## 进程地址空间布局 ##

* 栈，函数一旦被调用，就会生成一个栈帧（stack frame）。
* 堆，用户手动分配内存的区域，`malloc`和`free`。共享库和动态加载的模块，也存放于堆中。
* 未初始化数据段（.bss），bss段名字来自于"block started by symbel"-由符号开始的块。存放于此段的变量，在程序执行之前就被初始化为`0`或`Null`指针
* 已初始化数据段（.data .rodata），保存的是已经初始化了的全局变量和静态变量，它可以进一步划分为只读区域和可读写区域。
* 代码段（.text），保存可执行指令。

以上摘录于[C程序运行的背后](http://www.codeceo.com/article/c-program-run.html)

## 判断一指针指向对象是否已经被析构 ##

* 双重指针。直接指向对象的指针仅有一个，引用对象必须使用一个指向该指针的双重指针。当对象析构时，将那个直接指向对象的指针赋值为NULL。其他的双重指针就可以根据这个指针的值来判断对象是否被析构。
* 每创建一个对象，必须要与唯一的外部标识对应，外部标志的生存时间必须大于对象的生存时间；当确定不再需要查询对象的生存期时，应当释放外部标志。

以上摘录于[怎样判断一个指针指向的对象是否已经被析构](http://blog.donews.com/tabris17/archive/2005/03/27/315005.aspx)
