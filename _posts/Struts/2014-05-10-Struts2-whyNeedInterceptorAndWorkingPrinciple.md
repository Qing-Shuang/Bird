---
layout: default
tags: struts
title: Struts 学习笔记2--为什么需要拦截器及其工作原理
---

# Struts 学习笔记2--为什么需要拦截器及其工作原理 #

## 为什么要拦截请求 ##

拦截器承担了动作组件中的横切任务（cross-cutting task）、预处理（preprocessing）、后加工（postprocessing）。

* 横切任务举例：日志记录。
* 预处理举例：数据转移，通过params拦截器实现，即将一些数据从请求参数转移到特定领域的属性上。

在Struts2中，没有一个动作被单独调用。动作调用是一个分层的过程，总是包含一系列的拦截器在动作执行之前或者之后执行。框架不直接调用动作的 `execute()` 方法，而是创建一个叫做 `ActionInvocation` 的对象，它封装了动作和一系列被配置在动作执行之前之后触发的拦截器。

拦截器的强大功能之一是改变工作流。即某个拦截器会决定动作不应该执行。比如workflow拦截器。

## 拦截器的好处 ##

可重用和可配置。可配置意味着我们可以很容易地配置拦截器的顺序和数量。

## 拦截器的工作原理 ##

当框架收到一个请求时，它首先必须决定这个URL映射到哪个动作。这个动作的一个实例会被加入到一个新创建的 `ActionInvacation` 实例中。接着，框架会咨询声明性架构（通过应用程序的XML或者java注解创建），以发现哪些拦截器应该触发，及按照什么样的顺序触发。指向这些拦截器的**引用**被加入到 `ActionInvocation` 中。除了这些核心元素， `ActionInvocation` 也拥有对其他重要信息（例Servlet请求对象和当前动作可用的结果组件的映射）的**引用**。

 `ActionInvacation` 公开了 `invoke()` 方法，框架通过调用这个方法开始动作的执行。当框架调用这个方法时， `ActionInvocation` 通过执行拦截器栈中的第一个拦截器开始这个调用过程。注意，`invoke()` 方法并不总是映射到第一个拦截器，`ActionInvocation` 负责跟踪执行过程达到的状态，并且把控制交给栈中合适的拦截器。它通过调用拦截器的 `intercept()` 方法将控制权交给拦截器。`intercept()` 方法会把 `ActionInvocation` 实例作为一个参数，在拦截器的处理过程中，它会调用这个对象（ `ActionInvocation` 实例）上的 `invoke()` 方法继续调用后续拦截器的递归过程，在所有拦截器都被调用之后，`invoke()` 方法会促使动作类执行。

拦截器有一个三阶段的、有条件的执行周期：

* 在预处理阶段，拦截器能用来准备、过滤、改变或者操作任何可以访问的重要数据。这些数据包括所有与当前请求相关的关键对象和数据，也包括动作。

* 调用 `invoke()` 方法或者转移工作流。如果拦截器决定请求处理不应该继续，它可以不调用 `ActionInvocation` 实例上 `invoke()` 方法，而是直接返回一个控制字符串。通过这种方式，它可以停止后续执行，并且执行决定哪个结果会被呈现。

* 甚至 `invoke()` 方法返回控制字符串之后，任何一个返回的拦截器可以把随意决定改变任何可以访问的对象和数据作为它们的后加工。**需要注意，无论如何，现在结果页面已经被呈现了。**
	
	 
	