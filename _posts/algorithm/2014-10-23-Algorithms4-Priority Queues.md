# 算法学习笔记（4）-优先队列 #

摘录于[《算法》](http://book.douban.com/subject/19952400/)

## 优先队列 ##
许多应用程序都需要处理有序的元素，但不一定要求它们全部有序，或是不一定要一次就将它们排序。很多情况下我们会收集一些元素，处理当前键值最大的元素，然后再收集更多的元素，再处理当前键值最大的元素，如此这般。

优先队列的各种实现在最坏情况下运行时间的增长数量级:
数据结构 | 插入元素 | 删除最大元素
有序数组 | \\(N\\) | \\(1\\)
无序数组 | \\(1\\) | \\(N\\)
堆 | \\(logN\\) | \\(logN\\)
理想情况 | \\(1\\)	 | \\(1\\)

### 描述 ###
在二叉堆的数组中，每个元素都要保证大于等于另两个特定位置的元素。
二叉堆是一组能够用堆有序的完全二叉树排序的元素，并在数组中按照层级储存（不使用数组的第一个位置）。

### 命题 ###
**根节点是堆有序的二叉树中的最大结点。**

**一颗大小为\\(N\\)的完全二叉树的高度为\\(lgN\\)**

**对于一个含有\\(N\\)个元素的基于堆的优先队列，插入元素操作只需不超过\\((lgN+1)\\)次比较，删除最大元素的操作需要不超过\\(2lgN\\)次比较**

## 堆排序 ##

### 描述 ###
将所有元素插入一个查找最小元素的优先队列，然后再重复调用删除最小元素的操作来将它们按顺序删去。
如何构建一个堆？我们当然可以在与\\(NlogN\\)成正比的时间内完成这项任务，只需从左至右遍历数组，用`swim()`保证扫描指针左侧的所有元素已经是一颗堆有序的完全树即可，就像连续向优先队列中插入元素一样。一个更聪明更高效的方法是从右至左用`sink()`函数构造子堆。如果一个结点的两个子结点都已经是堆了，那么在该结点上调用`sink()`可以将它们变成一个堆。这个过程会递归地建立起堆的秩序。开始我们只需要扫描数组中的一半元素，因为我们可以跳过大小为1的子堆。

### 命题 ###
**用下沉操作由\\(N\\)个元素构造堆只需少于\\(2N\\)次比较以及少于\\(N\\)次交换。**

**将N个元素排序，堆排序只需少于\\((2NlgN+2N)\\)次比较（以及一半次数的交换）**

### 特点 ###
* 目前所知唯一能够同时最优地利用空间和时间的方法，在最坏的情况下它也能保证使用\\(~2NlgN\\)次比较和恒定的额外空间。

### 改进 ###
可以通过免去检查元素是否到达正确位置来节省时间，在下沉中总是直接提升较大的子结点直至到达堆底，然后再使元素上浮到正确的位置。这个想法几乎可以将比较次数减少一半--接近了归并排序所需的比较次数（随机数组）。这种方法需要额外的空间，因此在实际应用中只有当比较操作代价较高时才有用（例如，当我们在讲字符串或者其他键值较长类型的元素进行排序时）

<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

\\(\\)