---
layout: default
tags: algorithm
title: 算法学习笔记3-快速排序
---

# 算法学习笔记3-快速排序 #

摘录于[《算法》](http://book.douban.com/subject/19952400/)

## 快速排序 ##

### 描述 ###

是一种分治的的排序算法。它将一个数组分成两个子数组，将两部分独立地排序。归并中的递归调用发生在处理数组之前，快排中的递归调用发生在处理整个数组之后。归并是一个数组被分成两半，快排是切分（partition）的位置取决于数组的内容。

先随意取a[lo]作为切分元素，即那个将会被排定的元素，然后我们从数组的左端开始向右扫描知道找到一个大于等于它的元素，再从数组的右端开始向左扫描直到找到一个小于等于它的元素，交换它们的元素，如此继续直到左右相遇，并将相遇指向的元素与切分元素交换。

### 细节问题 ###

* 原地切分
* 别越界
* 保持随机性，对于预测算法的运行时间很重要
* 终止循环，一个最常见的错误是没有考虑到数组中可能包含和切分元素的值相同的其他元素
* 处理切分元素值有重复的情况
* 终止递归，一个常见的错误就是不能保证将切分元素放入正确的位置。从而导致程序在切分元素正好是子数组的最大或是最小元素陷入了无限的递归循环中

	备注：终止循环和终止递归需重新思考

### 命题 ###

* 将长度为N的无重复数组排序，快速排序平均需要\\(~2NlnN\\)次比较（以及\\(\frac{1}{6}\\)的交换）(\\(2NlnN\\)约等于\\(1.39NlgN\\)，也就是说平均比较次数只比最好情况多\\(39%\\))

* 快速排序最多需要约\\(\frac{N^2}{2}\\)次比较，但随机打乱数组能够预防这种情况
	
	备注：比如一个已经排好序的数组，或是一个重复元素的数组

### 特点 ###

* 原地排序（只需要一个很小的辅助栈）
* 内循环比大多数排序算法都要短小，这意味着它无论是在理论上还是在实际上都要更快
* 非常脆弱，在实现时要非常小心才能避免低劣的性能（平方级别）
* 在切分不平衡时可能会极为低效。比如一个从小到大的数组。
* 通常情况下会比归并快（尽管它的比较次数多\\(39%\\)），因为它移动数据的次数更少

### 改进 ###

* 对于小数组，切换到插入排序
* 三取样切分
* 墑最优的排序，实际应用中经常会出现含有大量重复元素的数组（见“三向切分的快速排序”）

## 三向切分的快速排序 ##

### 描述 ###

将数组切分为三部分，分别对应小于、等于和大于切分元素的数组元素。
从左向右遍历数组一次，一开始`lt=lo`，`gt=hi`，`i=lo+1`，`v`为`a[lo]`，
`a[i]`小于`v`，将`a[lt]`和`a[i]`交换，将`lt`和`i`加一；
`a[i]`大于`v`，将`a[gt]`和`a[i]`交换，将`gt`减一；
`a[i]`等于`v`，将`i`加一。
这些操作都会保证数组元素不变且缩小`gt-i`的值。

如下图所示：
| 小于v | 等于v | ...... | 大于v |

### 特点 ###

在数组中重复元素不多的情况下它比标准的二分法多使用了很多次交换。

### 改进 ###

Bently-Mcllroy三向切分：
使用两个索引`p`和`q`，使得`a[lo..p-1]`和`a[q+1..hi]`的元素都和`a[lo]`相等。使用另外两个索引`i`和`j`，使得`a[p..i-1]`小于`a[lo]`，`a[j+1..q]`大于`a[lo]`。在`a[i]`和`v`相等将其与`a[p]`交换（并将`p`加一），在`a[j]`和`v`相等且`a[i]`和`a[j]`尚未和`v`进行比较之前将其与`a[q]`交换。这里额外的交换用于和切分元素相等的元素。

如下图所示：
| 等于v | 小于v | ...... | 大于v | 等于v |


<script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=default"></script>

\\(\\)