---
layout: default
tags: python 
title: Python 源码学习笔记1--内建对象
---

# Python 源码学习笔记1--内建对象 #

Python的实现语言是ANSI C。C并不是面向对象的语言，那么在Python中，它的对象机制是如何实现的呢？

在计算机中，一个对象实际上就是一片被分配的内存空间，这些内存空间可能是连续的，也可能是离散的，这都不重要，重要的是这片内存在更高的层次上可以作为一个整体来考虑，这个整体就是一个对象。在这片内存中，存储着一系列的数据以及可以对这些数据进行修改或读取操作的一系列代码。

在Python中，对象就是为C中的结构体在堆上申请的一块内存，一般来说，对象是不能被静态初始化的，并且也不能在栈空间上生存，唯一的例外就是内建类型对象，Python所有的内建的类型对象都是被静态初始化的。

在Python中，对象被创建后，它在内存中的大小就是不变的了。这就意味着那些需要容纳可变长度数据的对象只能在对象内维护一个指向一块可变大小的内存区域的指针。**为什么要设定这样一条特殊的规则呢**，因为遵循这样的规则可以使通过指针维护对象的工作变的非常的简单。举例来说如果对象A的大小增大了，这意味着必须将A整个移动到内存中的其他位置，并且所有指向A的指针必须立即得到更新，这样的工作非常的繁琐。

## 对象机制的基石--PyObject ##

在Python中，所有的东西都是对象，而所有的对象都拥有一些相同的内容，这些内容在 `PyObject` 中定义， `PyObject` 是整个Python对象机制的核心，它的成员有： `ob_refcnt` 引用计数（与内存管理机制有关）、 `ob_type` 类型信息（一个指向 `_typeobject` 结构体的指针）。

在 `PyObject` 中定义了每一个Python对象都必须有的内容，这些内容将出现在每一个Python对象所占用的内存的**最开始**的字节中。

## 定长对象和变长对象 ##

表示变长对象的结构体为-- `PyVarObject` 。

变长对象与定长对象 `PyObject` 的区别在于多了一个成员： `ob_size`，这个成员实际上就是指明了变长对象中一共容纳了多少个元素。可以看出， `PyVarObject` 实际上只是对 `PyObject` 的一个扩展而已。

换句话说，在Python内部，每一个对象都拥有相同的对象头部。这使得在Python中，对对象的引用变得非常的统一，**只需要一个 `PyObject *` 指针就可以引用任意的一个对象**。  

## 类型对象 ##

占用空间的大小是对象的一种元信息，这样的元信息是与对象所属类型密切相关，因此它 `tp_basicsize` 一定会出现在与对象所对应的类型对象 `_typeobject` 中。

## 对象的创建 ##

Python内部通过两种方法创建对象：

* 通过Python的 C API 来创建。

* 通过类型对象 `PyInt_Type`（假设要创建一个整数对象）。

Python的 C API 分成两类：

* 一类称为泛型的API，或者称为 AOL（Abstract Object Layer）。这类API都具有诸如 `PyObject_***` 的形式，可以应用在任何Python对象身上。

* 另一类是与类型相关的API，或者称为 COL（Concrete Object Layer）。这类API通常只能作用与某一种类型的对象上。对于每一种**内建**对象，Python都提供了这样的一组API。

不论采用哪种 C API ，Python内部最终都是直接分配内存，因为Python对于内建对象是无所不知的。对于用户自定义的类型，是通过类型对象创建的。
 
