---
layout: default
tags: js
title: javascript 学习笔记(4)--原型模式
---

#javascript 学习笔记(4)--原型模式#

摘录于[《JavaScript高级程序设计:第2版》](http://book.douban.com/subject/4886879/)

每个函数都有一个`prototype`（原型）属性，这个属性是一个对象，它的用途是包含可以由特定类型的所有类型共享的属性和方法。

## 理解原型 ##

只要创建了一个新函数，就会根据一组特定的规则为该函数创建一个`prototype`属性。在默认情况下，所有`prototype`属性都会自动获得一个`constructor`（构造函数）属性，这个属性包含一个指向`prototype`属性所在函数的指针。

当调用构造函数创建一个新实例后，该实例的内部将包含一个指针（内容属性），指向构造函数的原型属性。在很多实现中，这个内部属性的名字是`_proto_`。就是这个链接存在于实例与构造函数的原型属性之间，而不是存在于实例与构造函数之间。

每当代码读取某个对象的某个属性时，如果在实例中找到了具有给定名字的属性，则返回属性的值；如果没有找到，则继续搜索指针指向的原型对象，在原型对象中查找具有给定名字的属性。

虽然可以通过对象实例访问保存在原型中的值，但却不能通过对象实例重写原型中的值。当为对象实例添加一个属性时，这个属性就会屏蔽原型对象中保存的**同名**属性。

## 更简单的原型语法 ##

每向对象`A`添加一个属性和方法就要敲一遍`A.prototype`，更简单更常见的做法是用一个包含所有属性和方法的对象字面量来重写整个原型对象。

这里本质上重写了默认的`prototype`对象，因此`constructor`属性也就变成了新对象的`constructor`属性（指向`Object`构造函数），不再指向`A`函数。

## 原型的动态性 ##

可以随时为原型添加属性和方法，并且修改能够立即在所有对象实例中反映出来，但如果重写了这个原型对象，情况就不一样了，就等于切断了构造函数与最初原型之间的联系。

## 原型对象的问题 ##

原型模式的最大问题是由其共享的本性导致的。当包含引用类型值得属性而我们又不希望该属性被共享时。实例一般都是要有属于自己的全部属性的。而这个问题正是我们很少看到有人单独使用原型模式的原因所在，创建自定义类型的最常见方式，就是组合使用构造函数模式与原型模式。构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。