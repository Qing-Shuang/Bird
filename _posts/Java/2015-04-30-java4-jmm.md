---
layout: default
tags: java
title: Java内存模型学习笔记
---

# Java内存模型学习笔记 #

摘录于[深入理解java内存模型系列文章](http://ifeve.com/java-memory-model-0/)

## 基础 ##

Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。

重排序分三种类型：1)编译器优化的重排序，2)指令级并行的重排序，3)内存系统的重排序。

* 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。
* 对于处理器重排序，JMM的处理器重排序规则会要求java编辑器在生成指令序列时，插入特定类型的内存屏障指令。

JMM的内存屏障指令有以下四类：

* LoadLoad：确保Load1数据的装载，之前与Load2及所有后续装载指令的装载。
* StoreStore：确保Store1数据对其他处理器可见（刷新到内存），之前于Store及所有后续存储指令的存储。
* LoadStore：确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。
* StoreLoad：确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。这是一个“全能型”的屏障，执行该屏障的开销很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中**（疑问：StoreStore屏障开销不大？）**

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在happens-before关系。
happens-before规则有：1)程序顺序规则，2)监视器锁规则，3)volatile变量规则，4)传递性。

## 重排序 ##

编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作。不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

as-if-serial语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编辑器，runtime和处理器都必须遵守as-if-serial语义。

在单线程中，对存在控制依赖的操作重排序，不会改变执行结果（这也是as-if-serial语义允许对存在控制依赖的操作做重排序的原因），但在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

## 顺序一致性 ##

JMM对**正确同步**的多线程程序的内存一致性做了如下保证：
如果程序时正确同步的，程序的执行将具有顺序一致性（sequentially consistent）-即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。

顺序一致性内存模型有两大特性：

* 一个线程中的所有操作必须按照程序的顺序来执行。
* （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

JMM在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。

对于未同步或未正确同步的多线程程序，JMM只提供最小安全性。为了实现最小安全性，JVM在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。

在JSR-133之前的旧内存模型中，一个64位`long/double`型变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位`long/double`型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性（即任意读操作必须要在单个读事物中执行）。

## volatile ##

锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的`long`型和`double`变量，只要它是volatile变量，对该变量的读写就将具有原子性。

volatile变量自身具有以下特性：

* 可见性：对一个volatile变量的读，总是能看到（任意线程）对这个volatile变量最后的写入。
* 原子性：对任意单个volatile变量的读/写具有原子性，但类似volatile这种复合操作不具有原子性。

volatile写-读的内存语义：

* 当写一个volatile变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
* 当读一个volatile变量时，JMM会把该线程对应的本地内存置为无效**（疑问：全部无效？）**，线程接下来将从主内存中读取共享变量。

volatile内存语义的实现：

* 当第二个操作时volatile写时，不管第一个操作是什么，都不能重排序。这个规则确保volatile写之前的操作不会被编译器重排序到volatile写之后。
* 当第一个操作时volatile读时，不管第二个操作是什么，都不能重排序。这个规则确保volatile读之后的操作不会被编译器重排序到volatile读之前。
* 当第一个操作时volatile写，第二个操作时volatile读时，不能重排序。

为了实现volatile的内存语义，下面是基于保守策略的JMM内存屏障插入策略：

* 在每个volatile写操作的前面插入一个StoreStore屏障。
* 在每个volatile写操作的后面插入一个StoreLoad屏障。（这个屏障的作用是避免volatile写与后面可能有的volatile读/写操作重排序。因为编译器常常无法准确判断在一个volatile写的后面，是否需要插入一个StoreLoad屏障，比如一个volatile写之后方法立即return）
* 在每个volatile读操作的后面插入一个LoadLoad屏障。
* 在每个volatile读操作的后面插入一个LoadStore屏障。

在旧的内存模型中，volatile的写-读没有锁的释放-获取所具有的内存语义，允许volatile变量与普通变量之间重排序。JSR-133通过严格限制编译器和处理器对volatile变量与普通变量的重排序增强volatile的内存语义。

## 锁 ##

锁释放获取与volatile写有相同的内存语义。

`ReentrantLock`的实现依赖于Java同步器框架AbstractQueuedSynchronizer(本文简称之为AQS)。AQS使用一个整型的volatile变量（命名为`state`）来维护同步状态。

`ReentrantLock`分为公平锁和非公平锁，它们的内存语义是：

* 公平锁和非公平锁释放锁时，最后都要写一个volatile变量`state`。
* 公平锁获取时，首先会去读这个volatile变量。
* 非公平锁获取时，首先会用CAS更新这个volatile变量，这个操作同时具有volatile读和volatile写的内存语义。（JDK文档对CAS的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。）

从`ReentrantLock`可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：

* 利用volatile变量的写-读所具有的内存语义。
* 利用CAS所附带的volatile读和volatile写的内存语义。