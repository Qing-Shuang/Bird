---
layout: default
tags: java
title: Java内存模型学习笔记
---

# Java内存模型学习笔记 #

摘录于[深入理解java内存模型系列文章](http://ifeve.com/java-memory-model-0/)

## 基础 ##

Java线程之间的通信由Java内存模型控制，JMM决定一个线程对共享变量的写入何时对另一个线程可见。JMM通过控制主内存与每个线程的本地内存之间的交互，来为java程序员提供内存可见性保证。

重排序分三种类型：1)编译器优化的重排序，2)指令级并行的重排序，3)内存系统的重排序。

* 对于编译器，JMM的编译器重排序规则会禁止特定类型的编译器重排序（不是所有的编译器重排序都要禁止）。
* 对于处理器重排序，JMM的处理器重排序规则会要求java编辑器在生成指令序列时，插入特定类型的内存屏障指令。

JMM的内存屏障指令有以下四类：

* `LoadLoad`：确保Load1数据的装载，之前与Load2及所有后续装载指令的装载。
* `StoreStore`：确保Store1数据对其他处理器可见（刷新到内存），之前于Store及所有后续存储指令的存储。
* `LoadStore`：确保Load1数据装载，之前于Store2及所有后续的存储指令刷新到内存。
* `StoreLoad`：确保Store1数据对其他处理器变得可见（指刷新到内存），之前于Load2及所有后续装载指令的装载。StoreLoad Barriers会使该屏障之前的所有内存访问指令（存储和装载指令）完成之后，才执行该屏障之后的内存访问指令。这是一个“全能型”的屏障，执行该屏障的开销很昂贵，因为当前处理器通常要把写缓冲区的数据全部刷新到内存中**（疑问：StoreStore屏障开销不大？）**

在JMM中，如果一个操作执行的结果需要对另一个操作可见，那么这两个操作之间必须存在`happens-before`关系。
`happens-before`规则有：1)程序顺序规则，2)监视器锁规则，3)volatile变量规则，4)传递性。

## 重排序 ##

编译器和处理器不会改变存在数据依赖关系的两个操作的执行顺序。这里所说的数据依赖性仅针对单个处理器中执行的指令序列和单个线程中执行的操作。不同处理器之间和不同线程之间的数据依赖性不被编译器和处理器考虑。

`as-if-serial`语义的意思指：不管怎么重排序（编译器和处理器为了提高并行度），（单线程）程序的执行结果不能被改变。编辑器，runtime和处理器都必须遵守`as-if-serial`语义。

在单线程中，对存在控制依赖的操作重排序，不会改变执行结果（这也是`as-if-serial`语义允许对存在控制依赖的操作做重排序的原因），但在多线程中，对存在控制依赖的操作重排序，可能会改变程序的执行结果。

## 顺序一致性 ##

JMM对**正确同步**的多线程程序的内存一致性做了如下保证：
如果程序时正确同步的，程序的执行将具有顺序一致性（sequentially consistent）-即程序的执行结果与该程序在顺序一致性内存模型中的执行结果相同。

顺序一致性内存模型有两大特性：

* 一个线程中的所有操作必须按照程序的顺序来执行。
* （不管程序是否同步）所有线程都只能看到一个单一的操作执行顺序。在顺序一致性内存模型中，每个操作都必须原子执行且立刻对所有线程可见。

JMM在不改变（正确同步的）程序执行结果的前提下，尽可能的为编译器和处理器的优化打开方便之门。

对于未同步或未正确同步的多线程程序，JMM只提供最小安全性。为了实现最小安全性，JVM在堆上分配对象时，首先会清零内存空间，然后才会在上面分配对象（JVM内部会同步这两个操作）。

在JSR-133之前的旧内存模型中，一个64位`long/double`型变量的读/写操作可以被拆分为两个32位的读/写操作来执行。从JSR-133内存模型开始（即从JDK5开始），仅仅只允许把一个64位`long/double`型变量的写操作拆分为两个32位的写操作来执行，任意的读操作在JSR-133中都必须具有原子性（即任意读操作必须要在单个读事物中执行）。

## volatile ##

锁的语义决定了临界区代码的执行具有原子性。这意味着即使是64位的`long`型和`double`变量，只要它是`volatile`变量，对该变量的读写就将具有原子性。

`volatile`变量自身具有以下特性：

* 可见性：对一个`volatile`变量的读，总是能看到（任意线程）对这个`volatile`变量最后的写入。
* 原子性：对任意单个`volatile`变量的读/写具有原子性，但类似`volatile`这种复合操作不具有原子性。

`volatile`写-读的内存语义：

* 当写一个`volatile`变量时，JMM会把该线程对应的本地内存中的共享变量刷新到主内存。
* 当读一个`volatile`变量时，JMM会把该线程对应的本地内存置为无效**（疑问：全部无效？）**，线程接下来将从主内存中读取共享变量。

`volatile`内存语义的实现：

* 当第二个操作时`volatile`写时，不管第一个操作是什么，都不能重排序。这个规则确保`volatile`写之前的操作不会被编译器重排序到`volatile`写之后。
* 当第一个操作时`volatile`读时，不管第二个操作是什么，都不能重排序。这个规则确保`volatile`读之后的操作不会被编译器重排序到`volatile`读之前。
* 当第一个操作时`volatile`写，第二个操作时`volatile`读时，不能重排序。

为了实现`volatile`的内存语义，下面是基于保守策略的JMM内存屏障插入策略：

* 在每个`volatile`写操作的前面插入一个StoreStore屏障。
* 在每个`volatile`写操作的后面插入一个StoreLoad屏障。（这个屏障的作用是避免volatile写与后面可能有的`volatile`读/写操作重排序。因为编译器常常无法准确判断在一个`volatile`写的后面，是否需要插入一个StoreLoad屏障，比如一个`volatile`写之后方法立即return）
* 在每个`volatile`读操作的后面插入一个LoadLoad屏障。
* 在每个`volatile`读操作的后面插入一个LoadStore屏障。

在旧的内存模型中，`volatile`的写-读没有锁的释放-获取所具有的内存语义，允许`volatile`变量与普通变量之间重排序。JSR-133通过严格限制编译器和处理器对`volatile`变量与普通变量的重排序增强`volatile`的内存语义。

## 锁 ##

锁释放获取与`volatile`写有相同的内存语义。

`ReentrantLock`的实现依赖于Java同步器框架AbstractQueuedSynchronizer(本文简称之为AQS)。AQS使用一个整型的`volatile`变量（命名为`state`）来维护同步状态。

`ReentrantLock`分为公平锁和非公平锁，它们的内存语义是：

* 公平锁和非公平锁释放锁时，最后都要写一个`volatile`变量`state`。
* 公平锁获取时，首先会去读这个`volatile`变量。
* 非公平锁获取时，首先会用CAS更新这个`volatile`变量，这个操作同时具有`volatile`读和`volatile`写的内存语义。（JDK文档对CAS的说明如下：如果当前状态值等于预期值，则以原子方式将同步状态设置为给定的更新值。）

从`ReentrantLock`可以看出，锁释放-获取的内存语义的实现至少有下面两种方式：

* 利用`volatile`变量的写-读所具有的内存语义。
* 利用CAS所附带的`volatile`读和`volatile`写的内存语义。

## final ##

写`final`域的重排序规则确保了在对象引用为任意线程可见之前，对象的`final`域已经被正确初始化过了，而普通域不具有这个保障，如下：

* JMM禁止编译器把`final`的写重排序到构造函数之外。
* 编译器会在`final`域的写之后，构造函数`return`之前，插入一个`StroreStore`屏障。这个屏障禁止处理器把`final`域的写重排序到构造函数之外。

读`final`域的重排序规则确保了在一个对象的`final`域之前，一定会先读包含这个`final`域的对象的引用：

* 在一个线程中，初次读对象引用与初次读该对象包含的`final`域，JMM禁止处理器重排序这两个操作（**注意，这个规则仅仅针对处理器，编译器遵守间接依赖关系**）。编译器会在读`final`域操作的前面插入一个`LoadLoad`屏障。

**对于引用类型**，写`final`域的重排序规则对编译器和处理器增加了如下约束：

* 在构造函数内对一个`final`引用的对象的成员域的写入，与随后在构造函数外把这个被构造对象的引用赋值给一个引用变量。这两个操作之前不能重排序。

由于x86处理器不会对写-写操作做重排序，所以在x86处理器中，写`final`域需要的`StroreStore`屏障会被省略掉。同样，由于x86处理器不会对存在间接依赖关系的操作做重排序，所以在x86处理器中，读`final`域需要的`LoadLoad`屏障也会被省略掉。也就是说在x86处理器中，`final`域的读/写不会插入任何内存屏障。

在旧的Java内存模型中，最严重的一个缺陷就是线程可能看到`final`域的值会改变。JSR-133提供了初始化保证：只要对象是正确构造的（被构造对象的引用在构造函数中没有“逸出”），那么不需要使用同步（指`lock`和`volatile`的使用），就可以保证任意线程都能看到这个`final`域在构造函数中被初始化之后的值。








