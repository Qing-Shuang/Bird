---
layout: default
tags: java
title: Java 学习笔记(1)--final
---

#Java 学习笔记(1)--final#

摘录于[《Java编程思想》](http://book.douban.com/subject/2130190/)

##final数据##

许多编程语言都有某种方法，来向编译器告知一块数据是恒定不变的。有时恒定不变是很有用的，比如：
* 一个永不改变的**编译时常量**
* 一个在运行时被初始化的值，而你不希望它被改变

在 java 中，编译期常量必须是基本数据类型，并且以关键字 final 表示。

一个既是 static 又是 final 的域只占据一段不能改变的存储空间。

对于对象引用，final 使引用恒定不变。对象其本身是可以被修改的。

static final 和 final 的区别在于 static final 的值不会因为创建第二个对象而发生改变，因为它是 static 的，在装载时已被初始化，而不是每次创建新对象时都初始化。

必须在域的定义处或者每个构造器中用表达式对 final 进行赋值

##final参数##

这意味着你无法在方法中更改参数引用所指向的对象。

基本类型的参数被指明为 final 时，你可以读参数，但却无法修改参数，这以特性主要用来向匿名内部类传递数据。

##final方法##

使用原因：把方法锁定，以防任何继承类修改它的含义。

##final和private关键字##

类中所有的 private 方法都可以隐式地指定为是 final 的。

“覆盖”只有在某方法是基类的接口的一部分才会出现。即必须能将一个对象想上转型为它的基本类型并调用相同的方法。如果某方法为 private ，它就不是基类的接口的一部分。它仅是一些隐藏于类中的程序代码，只不过是具有相同的名称而已。但如果在导出类中以相同的名称生成一个 public、protected 或包访问权限方法的话，该方法就不会产生在基类中出现的“仅具有相同名称”的情况。此时并没有覆盖该方法，仅是生成了一个新的方法。

##final类##

意味着出于某种考虑，你对该类的设计永不需要做任何变动，或者出于安全的考虑，你不希望它有子类。

final 类中所有的方法都隐式指定为是 final 的，因此无法覆盖它们。

##有关final的忠告##

**在将一个方法指定为 final 需慎重考虑**。比如Java1.0/1.1中 Vector 类被广泛的运用，人们可能会想要继承并覆盖如此基础而有用的类，但是设计者却认为这样做不太合适。而同样在Java1.0/1.1中的一个重要的标准库类 Hashtable 不含任何 final ，由此也可以看出某些类明显是由一些互不相干的人设计的。

现代 Java 的容器库用 ArrayList 替代了 Vector ，用 HashMap 替代了 Hashtable 。

