---
layout: default
tags: concurrency
title: 并发编程学习笔记（2）-对象的共享
---

#并发编程学习笔记（2）-对象的共享#

摘录于[《Java并发编程实战》](http://book.douban.com/subject/10484692/)

##发布与逸出##

“发布（Publish）”一个对象的意思是指，使对象能够在当前作用域之外的代码使用。发布对象时要确保线程安全性，则可能需要同步。发布内部状态可能会破坏封装性，并使得程序难以维持不变性条件。例如，如果在对象构造完成之前就发布对象，就会破坏线程安全性。但某个不应该发布的对象被发布时，这种情况就被称为逸出（Escape）。

如果一个已经发布的对象能够通过非私有的的变量引用和方法调用到达其他的对象，那么这些对象也都会被发布。

无论其他的线程会对已发布的引用执行何种操作，其实都不重要，因为误用该引用的风险始终存在。

###安全的对象构造过程###

**当且仅当对象的构造函数返回时，对象才处于可预测的和一致的状态**。因此，当从对象的构造函数中发布对象时，只是发布了一个尚未构造完成的对象。即使发布对象的语句位于构造函数的最后一行也是如此。如果this引用在构造过程中逸出，那么这种对象就被认为是不正确构造。

在构造过程中使 `this` 引用逸出的一个常见错误是，在构造函数中启动一个线程，这样 `this` 引用会被新创建的线程共享。在构造函数中创建线程并没有错误，但最好不要立即启动它，而是通过一个 `start` 或 `initialize` 方法来启动。在构造函数中调用一个可改变的实例方法时（即不是私有方法也不是终结方法），同样会导致 `this` 引用在构造过程中逸出。

如果想在构造函数中注册一个事件监听器或启动线程，那么可以使用一个私有的构造函数和一个公共的工厂方法（Factory Method），从而避免不正确的构造过程。

##线程封闭##

如果仅在单线程内访问数据，就不需要同步。这种技术被称为线程封闭（Thread Confinement），它是实现线程安全性的最简单方式之一。当某个对象封闭在一个线程中时，这种用法将自动实现线程安全性，即使被封闭的对象本身不是线程安全的。

例如：
* Swing 的可视化组件和数据模型对象都不是线程安全的，Swing 通过将它们封闭到 Swing 的事件分发线程中来实现线程安全性。
* JDBC（Java Database Connectivity）的 `Connection` 对象。该对象在返回连接池之前，连接池都不会再将它分配给其他线程。

###Ad-hoc 线程封闭###

Ad-hoc 线程封闭是指，维护线程封闭性的职责完全由程序实现来承担。Ad-hoc 线程封闭是非常脆弱的，因为没有任何一种语言特性，例如可见性修饰符或局部变量，能将对象封闭到目标线程上。

当决定使用线程封闭技术时，通常是因为要将某个特定的子系统实现为一个单线程子系统。

在 `volatile` 变量上存在一种特殊的线程封闭。

###栈封闭###

在栈封闭中，只能通过局部变量才能访问对象。局部变量的固有属性之一就是封闭在执行线程中。它们位于执行线程的栈中，其他线程无法访问这个栈。

对于基本类型的局部变量，无论如何都不会破坏栈封闭性。因为任何方法都无法获得对基本类型的引用。
		
	C#存在特性可以获得对基本的类型的引用。

在维持对象引用的栈封闭性时，需要确保被引用的对象（或者该对象中的任何内部数据）不会逸出。

###ThreadLocal 类###

这个类能使线程中的某个值与保存值的对象关联起来。ThreadLocal 提供了 `get` 与 `set` 等访问接口或方法，这些方法为每个使用该变量的线程都存有一份独立的副本，因此 `get` 总是返回由当前执行线程在调用 `set` 时设置的最新值。

ThreadLocal 对象通常用于防止对可变的单实例变量（Singleton）或全局变量进行共享。比如一个全局的数据库连接。

当某个频繁执行的操作需要一个临时对象，例如一个缓冲区，而同时又希望避免在每次执行时都重新分配该临时对象，就可以使用这项技术。例如在 Java5.0 之前的 `Integer.toString()`。
（除非这个操作的执行频率非常高，或者分配操作的开销非常高，否则这项技术不可能带来性能提升，Java5.0 的 `Integer.toString()` 在每次调用时分配一个新的缓冲区。）

在实现应用程序框架时大量使用了 ThreadLocal 。例如，在 EJB 调用期间，J2EE 容器需要将一个事务上下文（Transaction Context）与某个执行中的线程关联起来。这种机制很方便，因为它避免了调用每个方法时都要传递上下文信息，然而这也将使用该机制的代码与框架耦合在一起。

不要滥用 ThreadLocal ，例如将所有全局变量都作为 ThreadLocal 对象，或者作为一种“隐藏”方法参数的手段。



